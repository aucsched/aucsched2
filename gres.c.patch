--- src/common/gres.c	2013-01-03 22:45:38.000000000 +0200
+++ src/common/gres.c	2013-01-17 15:52:31.000000000 +0200
@@ -169,7 +169,7 @@
 			       slurm_gres_context_t *context_ptr);
 static void	_node_state_dealloc(gres_state_t *gres_ptr);
 static void *	_node_state_dup(void *gres_data);
-static void	_node_state_log(void *gres_data, char *node_name,
+static int	_node_state_log(void *gres_data, char *node_name,
 				char *gres_name);
 static int	_parse_gres_config(void **dest, slurm_parser_enum_t type,
 				   const char *key, const char *value,
@@ -346,7 +346,7 @@
 		gres_debug = true;
 	else
 		gres_debug = false;
-
+	gres_debug = true;
 	if (gres_context_cnt >= 0)
 		goto fini;
 
@@ -1948,7 +1948,7 @@
 	slurm_mutex_unlock(&gres_context_lock);
 }
 
-static void _node_state_log(void *gres_data, char *node_name, char *gres_name)
+static int _node_state_log(void *gres_data, char *node_name, char *gres_name)
 {
 	gres_node_state_t *gres_node_ptr;
 	int i;
@@ -1956,6 +1956,7 @@
 
 	xassert(gres_data);
 	gres_node_ptr = (gres_node_state_t *) gres_data;
+	/*
 	info("gres/%s: state for %s", gres_name, node_name);
 	info("  gres_cnt found:%u configured:%u avail:%u alloc:%u",
 	     gres_node_ptr->gres_cnt_found, gres_node_ptr->gres_cnt_config,
@@ -1966,6 +1967,7 @@
 	} else {
 		info("  gres_bit_alloc:NULL");
 	}
+	*/
 	for (i=0; i<gres_node_ptr->topo_cnt; i++) {
 		if (gres_node_ptr->topo_cpus_bitmap[i]) {
 			bit_fmt(tmp_str, sizeof(tmp_str),
@@ -1984,6 +1986,7 @@
 		info("  topo_gres_cnt_avail[%d]:%u",i,
 		     gres_node_ptr->topo_gres_cnt_avail[i]);
 	}
+	return gres_node_ptr->gres_cnt_avail - gres_node_ptr->gres_cnt_alloc;
 }
 
 /*
@@ -1991,14 +1994,14 @@
  * IN gres_list - generated by gres_plugin_node_config_validate()
  * IN node_name - name of the node for which the gres information applies
  */
-extern void gres_plugin_node_state_log(List gres_list, char *node_name)
+extern int gres_plugin_node_state_log(List gres_list, char *node_name)
 {
-	int i;
+	int i, remaining = 0;
 	ListIterator gres_iter;
 	gres_state_t *gres_ptr;
 
 	if (!gres_debug || (gres_list == NULL))
-		return;
+		return 0;
 
 	(void) gres_plugin_init();
 
@@ -2009,13 +2012,19 @@
 			if (gres_ptr->plugin_id !=
 			    gres_context[i].plugin_id)
 				continue;
-			_node_state_log(gres_ptr->gres_data, node_name,
-					gres_context[i].gres_name);
+			if (strcmp(gres_context[i].gres_name,"gpu") == 0)
+				remaining = _node_state_log(gres_ptr->gres_data, node_name,
+						gres_context[i].gres_name);
+			else
+				_node_state_log(gres_ptr->gres_data, node_name,
+						gres_context[i].gres_name);
 			break;
 		}
 	}
 	list_iterator_destroy(gres_iter);
 	slurm_mutex_unlock(&gres_context_lock);
+
+	return remaining;
 }
 
 static void _job_state_delete(void *gres_data)
@@ -2038,6 +2047,40 @@
 	xfree(gres_ptr);
 }
 
+/*
+returns number of gres types defined
+*/
+extern int gres_cnt() {
+	return gres_context_cnt;
+}
+
+/*
+returns number of gpus for a specific node
+*/
+extern int gres_job_gpu_count(List job_gres_list) {
+       int i;
+       ListIterator job_gres_iter;
+       gres_state_t *job_gres_ptr;
+       gres_job_state_t  *job_gres_ptr2;
+
+       if (job_gres_list == NULL)
+               return 0;
+
+       (void) gres_plugin_init();
+       job_gres_iter = list_iterator_create(job_gres_list);
+       while ((job_gres_ptr = (gres_state_t *) list_next(job_gres_iter))) {
+               for (i=0; i<gres_context_cnt; i++) {
+                       if (strcmp(gres_context[i].gres_name,"gpu") == 0) {
+                               job_gres_ptr2 = (gres_job_state_t *)
+                                       job_gres_ptr->gres_data;
+                               return job_gres_ptr2->gres_cnt_alloc;
+                       }
+               }
+       }
+       return 0;
+}
+
+
 static void _gres_job_list_delete(void *list_element)
 {
 	gres_state_t *gres_ptr;
